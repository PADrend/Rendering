/*
	This file is part of the Rendering library.
	Copyright (C) 2007-2012 Benjamin Eikel <benjamin@eikel.org>
	Copyright (C) 2007-2012 Claudius JÃ¤hn <claudius@uni-paderborn.de>
	Copyright (C) 2007-2012 Ralf Petring <ralf@petring.net>
  Copyright (C) 2018 Sascha Brandt <sascha@brandt.graphics>
	
	This library is subject to the terms of the Mozilla Public License, v. 2.0.
	You should have received a copy of the MPL along with this library; see the 
	file LICENSE. If not, you can obtain one at http://mozilla.org/MPL/2.0/.
*/
#ifndef PLATONICSOLIDS_H_
#define PLATONICSOLIDS_H_

#include "../Mesh/VertexDescription.h"

#include <cstdint>

namespace Rendering {
class Mesh;
namespace MeshUtils {
class MeshBuilder;

//! @ingroup mesh_builder
namespace PlatonicSolids {


/**
 * Return a mesh containing a tetrahedron (4 vertices, 4 triangles).
 * The tetrahedron is centered at the origin and the vertices are lying on the unit sphere.
 * Positions and normals for the vertices are generated.
 *
 * @return Tetrahedron Mesh
 */
Mesh * createTetrahedron(const VertexDescription& vd);
inline Mesh * createTetrahedron() {
  VertexDescription vd;
  vd.appendPosition3D();
  vd.appendNormalFloat();
  vd.appendColorRGBAByte();
  return createTetrahedron(vd);
}
void addTetrahedron(MeshBuilder& mb);

/**
 * Return a mesh containing a cube (8 vertices, 6 squares).
 * The cube is centered at the origin and the vertices are lying on the unit sphere.
 * Positions and normals for the vertices are generated.
 *
 * @return Cube Mesh
 */
Mesh * createCube(const VertexDescription& vd);
inline Mesh * createCube() {
  VertexDescription vd;
  vd.appendPosition3D();
  vd.appendNormalFloat();
  vd.appendColorRGBAByte();
  return createCube(vd);
}
void addCube(MeshBuilder& mb);

/**
 * Return a mesh containing an octahedron (6 vertices, 8 triangles).
 * The octahedron is centered at the origin and the vertices are lying on the unit sphere.
 * Positions and normals for the vertices are generated.
 *
 * @return Octahedron Mesh
 */
Mesh * createOctahedron(const VertexDescription& vd);
inline Mesh * createOctahedron() {
  VertexDescription vd;
  vd.appendPosition3D();
  vd.appendNormalFloat();
  vd.appendColorRGBAByte();
  return createOctahedron(vd);
}
void addOctahedron(MeshBuilder& mb);

/**
 * Return a mesh containing a dodecahedron (20 vertices, 12 pentagons).
 * Each face is split into three triangles (36 triangles overall).
 * The dodecahedron is centered at the origin and the vertices are lying on the unit sphere.
 * Positions and normals for the vertices are generated.
 *
 * @return Dodecahedron Mesh
 */
Mesh * createDodecahedron(const VertexDescription& vd);
inline Mesh * createDodecahedron() {
  VertexDescription vd;
  vd.appendPosition3D();
  vd.appendNormalFloat();
  vd.appendColorRGBAByte();
  return createDodecahedron(vd);
}
void addDodecahedron(MeshBuilder& mb);

/**
 * Return a mesh containing an icosahedron (12 vertices, 20 triangles).
 * The icosahredron is centered at the origin and the vertices are lying on the unit sphere.
 * Positions and normals for the vertices are generated.
 *
 * @return Icosahedron Mesh
 */
Mesh * createIcosahedron(const VertexDescription& vd);
inline Mesh * createIcosahedron() {
  VertexDescription vd;
  vd.appendPosition3D();
  vd.appendNormalFloat();
  vd.appendColorRGBAByte();
  return createIcosahedron(vd);
}
void addIcosahedron(MeshBuilder& mb);

/**
 * Return a sphere which is generated by subdividing the edges of a platonic solid.
 * A platonic solid with triangular faces is needed in this implementation.
 * For each subdivision the number of triangles is quadrupled.
 * The sphere is centered at the origin and the vertices are lying on the unit sphere.
 * Positions and normals for the vertices are generated.
 *
 * @param platonicSolid A tetrahedron, an octahedron, or an icosahedron.
 * @param subdivisions Number of subdivision steps.
 * @return Subdivision Sphere Mesh, or @c nullptr if the given platonic solid could not be used.
 * @see createTetrahedron()
 * @see createOctahedron()
 * @see createIcosahedron()
 */
Mesh * createEdgeSubdivisionSphere(Mesh * platonicSolid, uint8_t subdivisions);

}
}
}

#endif /* PLATONICSOLIDS_H_ */
