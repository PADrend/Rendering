/*
  This file is part of the Rendering library.
  Copyright (C) 2007-2012 Benjamin Eikel <benjamin@eikel.org>
  Copyright (C) 2007-2012 Claudius JÃ¤hn <claudius@uni-paderborn.de>
  Copyright (C) 2007-2012 Ralf Petring <ralf@petring.net>
  Copyright (C) 2018 Sascha Brandt <sascha@brandt.graphics>

  This library is subject to the terms of the Mozilla Public License, v. 2.0.
  You should have received a copy of the MPL along with this library; see the
  file LICENSE. If not, you can obtain one at http://mozilla.org/MPL/2.0/.
*/

#ifndef RENDERING_MESHUTILS_PRIMITIVESHAPES_H_
#define RENDERING_MESHUTILS_PRIMITIVESHAPES_H_

#include <Geometry/Rect.h>
#include <Util/References.h>

#include <cstdint>

namespace Geometry {
template<typename value_t> class _Box;
typedef _Box<float> Box;
template<typename _T> class _Matrix4x4;
typedef _Matrix4x4<float> Matrix4x4;
template<typename T_> class _SRT;
typedef _SRT<float> SRT;
template<typename _T> class _Vec2;
typedef _Vec2<float> Vec2;
template<typename _T> class _Vec3;
typedef _Vec3<float> Vec3;
typedef _Vec3<float> Vec3f;
typedef _Vec3<char> Vec3b;
template<typename T_>
class _Sphere;
typedef _Sphere<float> Sphere_f;
}

namespace Util {
class Color4f;
class Color4ub;
class PixelAccessor;
}

namespace Rendering {
class Mesh;
class VertexDescription;
namespace MeshUtils {
class MeshBuilder;

//! @addtogroup mesh_builder
//! @{

/**
 * Return the mesh of a three-dimensional, axis-aligned box.
 * Positions, and normals are supported.
 *
 * @param vd Vertex description specifying the vertex information to generate
 * @param box Geometric specification of the box
 * @return Mesh of the box
 */
Mesh* createBox(const VertexDescription& vd, const Geometry::Box& box);
  
//! Adds a box to the given meshBuilder. \see createBox(...)
void addBox(MeshBuilder& mb, const Geometry::Box& box);

/*! Creates a mesh for a sky dome with texture coordinates.
  \note adapted from [alc] http://irrlicht.sourceforge.net/phpBB2/viewtopic.php?t=13887&sid=25788d2b93c73294fd7abe76db6fab1e */
Mesh* createDome(const VertexDescription& vd, const double radius = 100.0, const int horiRes = 40, const int vertRes = 40, const double halfSphereFraction = 1.0, const double imagePercentage = 1.0);

//! Adds a dome to the given meshBuilder. \see createDome(...)
void addDome(MeshBuilder& mb, const double radius = 100.0, const int horiRes = 40, const int vertRes = 40, const double halfSphereFraction = 1.0, const double imagePercentage = 1.0);

 
/**
 * Return a sphere, which is generated by subdividing the sphere surface into segements.
 * The surface is subdivided into the given number of subdivisions of the inclination angle and the azimuth angle, respectively.
 * The sphere is centered at the origin and the vertices are lying on the unit sphere.
 * The given vertex description specifies which information is generated for every vertex.
 * Positions, normals, colors, and texture coordinates are supported.
 *
 * @param vd Vertex description specifying the vertex information to generate
 * @param inclinationSegments Number of subdivisions of the inclination angle
 * @param azimuthSegments Number of subdivisions of the azimuth angle
 * @return Sphere Mesh
 */
Mesh* createSphere(const VertexDescription& vd, const Geometry::Sphere_f& sphere, uint32_t inclinationSegments, uint32_t azimuthSegments);

//! Adds a shere to the given meshBuilder. \see createSphere(...)
void addSphere(MeshBuilder& mb, const Geometry::Sphere_f& sphere, uint32_t inclinationSegments, uint32_t azimuthSegments);

/**
 * Return a sector of a disc.
 * The center of the disc is the origin.
 * The disc is aligned with the y-z plane and the normals are pointing into negative x direction.
 * Positions and normals for the vertices are generated.
 *
 * @param vd Vertex description specifying the vertex information to generate
 * @param radius Radius of the disc
 * @param numSegments Number of segments for the disc
 * @param angle Central angle of the sector in degrees
 * @return Disc Mesh or @c nullptr if the number of segments is smaller than two.
 */
Mesh* createDiscSector(const VertexDescription& vd, float radius, uint8_t numSegments, float angle = 360.0f);

//! Adds a disc sector to the given meshBuilder. \see createDiscSector(...)
void addDiscSector(MeshBuilder& mb, float radius, uint8_t numSegments, float angle = 360.0f);

 /**
 * Return a sector of a ring.
 * The center of the disc is the origin.
 * The disc is aligned with the y-z plane and the normals are pointing into negative x direction.
 * Positions and normals for the vertices are generated.
 *
 * @param vd Vertex description specifying the vertex information to generate
 * @param innerRadius inner radius of the ring
 * @param outerRadius outer radius of the ring
 * @param numSegments Number of segments for the disc
 * @param angle Central angle of the sector in degrees
 * @return Disc Mesh or @c nullptr if the number of segments is smaller than two or innerRadius >= outerRadius
 */
Mesh* createRingSector(const VertexDescription& vd, float innerRadius, float outerRadius, uint8_t numSegments, float angle = 360.0f);

//! Adds a ring sector to the given meshBuilder. \see createRingSector(...)
void addRingSector(MeshBuilder& mb, float innerRadius, float outerRadius, uint8_t numSegments, float angle = 360.0f);

/**
 * Return a cone with the radius given.
 * The cap end is not created.
 * The center of the base is the origin.
 * The apex lies on the x-axis at distance @a height from the origin.
 * Positions and normals for the vertices are generated.
 *
 * @param vd Vertex description specifying the vertex information to generate
 * @param radius Radius of the base
 * @param height Distance between the base and the apex
 * @param numSegments Number of segments for the circle at the base and the lateral surface
 * @return Cone Mesh or @c nullptr if the number of segments is smaller than two
 * @see createDisc() for creation of a cap end
 */
Mesh* createCone(const VertexDescription& vd, float radius, float height, uint8_t numSegments);

//! Adds a cone to the given meshBuilder. \see createCone(...)
void addCone(MeshBuilder& mb, float radius, float height, uint8_t numSegments);

/**
 * Return a conical frustum with the radii given.
 * The cap ends are not created.
 * The center of the bottom circle is the origin.
 * The center of the top circle lies on the x-axis at distance @a height from the origin.
 * If both radii have the same value, a cylinder is created.
 * Positions and normals for the vertices are generated.
 *
 * @param vd Vertex description specifying the vertex information to generate
 * @param radiusBottom Radius of the bottom circle
 * @param radiusTop Radius of the top circle
 * @param height Distance between both circles
 * @param numSegments Number of segments for the circles and the lateral surface
 * @return Conical frustum Mesh or @c nullptr if the number of segments is smaller than two
 * @see createDisc() for creation of cap ends
 */
Mesh* createConicalFrustum(const VertexDescription& vd, float radiusBottom, float radiusTop, float height, uint8_t numSegments);

//! Adds a conical frustum to the given meshBuilder. \see createConicalFrustum(...)
void addConicalFrustum(MeshBuilder& mb, float radiusBottom, float radiusTop, float height, uint8_t numSegments);

/**
 * Returns an arrow which consists of a ConicalFrustum and 2 Cones at one end.
 *
 * @param vd Vertex description specifying the vertex information to generate
 * @param radius Radius of the arrow
 * @param length Overall length of the arrow
 * @return Arrow Mesh
 */
Mesh* createArrow(const VertexDescription& vd, float radius, float length);

//! Adds an arrow to the given meshBuilder. \see createArrow(...)
void addArrow(MeshBuilder& mb, float radius, float length);

/**
 * Returns a Rectangle consisting of 2 triangles (oriented in x-y-plane)
 *
 * @param vd Vertex description specifying the vertex information to generate
 * @param rect the rectangle
 * @return Rectangle Mesh
 */
Mesh* createRectangle(const VertexDescription& vd, const Geometry::Rect_f& rect);

/**
 * Returns a Rectangle consisting of 2 triangles with origin in the center (oriented in x-y-plane)
 *
 * @param vd Vertex description specifying the vertex information to generate
 * @param width The width of the rectangle 
 * @param height The height of the rectangle 
 * @return Rectangle Mesh
 */
inline Mesh* createRectangle(const VertexDescription& vd, float width, float height) {
  return createRectangle(vd, Geometry::Rect_f{width*-0.5f,height*-0.5f,width,height});
}

//! Adds an rectangle to the given meshBuilder. \see createRectangle(...)
void addRectangle(MeshBuilder& mb, const Geometry::Rect_f& rect);
//! Adds an rectangle to the given meshBuilder. \see createRectangle(...)
inline void addRectangle(MeshBuilder& mb, float width, float height) {
  addRectangle(mb, Geometry::Rect_f{0,0,width,height});
}

/**
 * Creates a rectangular grid in the x-z-plane.
 *
 * @param vd Vertex description specifying the vertex information to generate
 * @param width The width of the grid 
 * @param height The height of the grid 
 * @param rows number of rows 
 * @param columns number of columns 
 */              
Mesh* createGrid(const VertexDescription& vd, float width, float height, uint32_t rows, uint32_t columns);

//! Adds a rectangular grid to the given meshBuilder. \see createGrid(...)
void addGrid(MeshBuilder& mb, float width, float height, uint32_t rows, uint32_t columns);

/**
 * Creates a hexagonal grid in the x-z-plane.
 *
 * @param vd Vertex description specifying the vertex information to generate
 * @param width The width of the grid 
 * @param height The height of the grid 
 * @param rows number of rows. Needs to be at least 3
 * @param columns number of columns. Needs to be at least 4
 */              
Mesh* createHexGrid(const VertexDescription& vd, float width, float height, uint32_t rows, uint32_t columns);

//! Adds a hexagonal grid to the given meshBuilder. \see createHexGrid(...)
void addHexGrid(MeshBuilder& mb, float width, float height, uint32_t rows, uint32_t columns);

/**
 * Creates a mesh from a voxel bitmap as exported from a 3D Texture.
 * The bitmap should have a height of depth*heiht, i.e., each depth layer is stored from top to bottom in the vertical direction of the bitmap.
 * The height and width of the voxel grid is derived from the bitmap width and height. The actual height of the voxel grid is bitmap-height/depth.
 * A voxel box of size 1^3 is created for every pixel with a positive alpha value. 
 * The local point (0,0,0) in the resulting mesh corresponds to the (0,0,0) coordinate in the voxel bitmap.
 * To scale the mesh afterwards, use MeshUtils::transform
 *
 * @param vd Vertex description specifying the vertex information to generate
 * @param colorAcc the bitmap that defines the voxel grid. Every pixel with non-zero alpha value defines a voxel.
 * @param the depth of the voxel grid. The height of the bitmap should be divisible by this value
 */
Mesh* createVoxelMesh(const VertexDescription& vd, const Util::PixelAccessor& colorAcc, uint32_t depth);

//! Adds a voxel mesh to the given meshBuilder. \see createHexGrid(...)
void addVoxelMesh(MeshBuilder& mb, const Util::PixelAccessor& colorAcc, uint32_t depth);

 /**
 * Creates a torus mesh.
 * The center of the torus is located at the origin.
 * The aligned is aligned with the x-z plane.
 *
 * @param vd Vertex description specifying the vertex information to generate
 * @param innerRadius inner radius of the torus. Should be greater than or equal 0.
 * @param outerRadius outer radius of the torus. Should be greater than inner radius.
 * @param majorSegments Number of major segments. Minimum is 3.
 * @param minorSegments Number of minor segments. Minimum is 3.
 * @return The mesh
 */
Mesh* createTorus(const VertexDescription& vd, float innerRadius, float outerRadius, uint32_t majorSegments, uint32_t minorSegments);

//! Adds a torus to the MeshBuilder. \see addTorus(...)
void addTorus(MeshBuilder& mb, float innerRadius, float outerRadius, uint32_t majorSegments, uint32_t minorSegments);

  
/**
* Creates a mesh from the input bitmap.
*
* @param vd Vertex description specifying the vertex information to generate
* @param depth Bitmap with depth values. Translates to the y-values of the mesh.
* @param color Bitmap with colors.
* @param normals Bitmap with normals.
* @return The mesh
*/
Mesh* createMeshFromBitmaps(const VertexDescription& vd, Util::Reference<Util::PixelAccessor> depth, Util::Reference<Util::PixelAccessor> color = nullptr, Util::Reference<Util::PixelAccessor> normals = nullptr);
  
//! Adds a mesh from bitmap to the given meshBuilder. \see createMeshFromBitmaps(...)
void addMeshFromBitmaps(MeshBuilder& mb, Util::Reference<Util::PixelAccessor> depth, Util::Reference<Util::PixelAccessor> color = nullptr, Util::Reference<Util::PixelAccessor> normals = nullptr);

//! @}
}
} /* Rendering */

#endif /* end of include guard: RENDERING_MESHUTILS_PRIMITIVESHAPES_H_ */
